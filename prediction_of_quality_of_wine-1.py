# -*- coding: utf-8 -*-
"""prediction-of-quality-of-wine.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ks-qz9M9qpeLNQYBcxnmEtxHqYwpA0D7

*In this notebook, First I have done some exploration on the data using matplotlib and seaborn.
Then, I use different classifier models to predict the quality of the wine.*

**1. Random Forest Classifier**

**2. Support Vector Classifier(SVC) **

*Then I use cross validation evaluation technique to optimize the model performance.*

**1. Grid Search CV**

**2. Cross Validation Score**
"""

# Commented out IPython magic to ensure Python compatibility.
#Importing required packages.
import pandas as pd
import seaborn as sns   #statistical visualizations, such as heatmaps, distribution plots, and regression plots.
import matplotlib.pyplot as plt #for creating static, interactive, and animated visualizations in Python
import io
from sklearn.ensemble import RandomForestClassifier   # It provides a wide range of tools for various tasks such as classification, regression, clustering, model selection, and data preprocessing
from sklearn.svm import SVC
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
# %matplotlib inline

from google.colab import files
 
 
uploaded = files.upload()

#Loading dataset
wine = pd.read_csv(io.BytesIO(uploaded['winequality-red.csv']))
print(wine)

#Let's check how the data is distributed
wine.head()

#Information about the data columns
wine.info()

"""## **Let's do some plotting to know how the data columns are distributed in the dataset**"""

#Here we see that fixed acidity does not give any specification to classify the quality.
fig = plt.figure(figsize = (10,6))    #figsize is a tuple of the width and height of the figure in inches
sns.barplot(x = 'quality', y = 'fixed acidity', data = wine)

#Here we see that its quite a downing trend in the volatile acidity as we go higher the quality 
fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'volatile acidity', data = wine)

#Composition of citric acid go higher as we go higher in the quality of the wine
fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'citric acid', data = wine)

fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'residual sugar', data = wine)

#Composition of chloride also go down as we go higher in the quality of the wine
fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'chlorides', data = wine)

fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'free sulfur dioxide', data = wine)

fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'total sulfur dioxide', data = wine)

#Sulphates level goes higher with the quality of wine
fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'sulphates', data = wine)

#Alcohol level also goes higher as te quality of wine increases
fig = plt.figure(figsize = (10,6))
sns.barplot(x = 'quality', y = 'alcohol', data = wine)

"""## Preprocessing Data for performing Machine learning algorithms"""

#Making binary classificaion for the response variable.
#Dividing wine as good and bad by giving the limit for the quality
bins = (2, 6.5, 8)
group_names = ['bad', 'good']
wine['quality'] = pd.cut(wine['quality'], bins = bins, labels = group_names)

#Now lets assign a labels to our quality variable
label_quality = LabelEncoder()  

#Bad becomes 0 and good becomes 1 
wine['quality'] = label_quality.fit_transform(wine['quality'])

wine['quality'].value_counts()

sns.countplot(wine['quality'])

#Now seperate the dataset as response variable(dependent variable or target variable) and feature variabes( independent variables, input variables )
X = wine.drop('quality', axis = 1)    # the response variable is the variable being predicted or modeled, while the feature variables are the input variables used to make the prediction or model.
y = wine['quality']

#Train and Test splitting of data 
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)


"""the purpose of StandardScaler is to transform the features of a dataset so that they have a standard scale and distribution. This is important because some machine learning algorithms may be sensitive to the scale and distribution of the input features. By scaling the features to have the same range and distribution, we can help the machine learning algorithm to better understand the relative importance of each feature and make better predictions. In other words, the StandardScaler ensures that all features are weighted equally during the training process, which can improve the accuracy and reliability of the machine learning model."""

#Applying Standard scaling to get optimized result
sc = StandardScaler()


X_train = sc.fit_transform(X_train)
X_test = sc.fit_transform(X_test)

"""## Our training and testing data is ready now to perform machine learning algorithm

### Random Forest Classifier
"""

rfc = RandomForestClassifier(n_estimators=200) # These hyperparameters control the number of trees in the forest
rfc.fit(X_train, y_train)
pred_rfc = rfc.predict(X_test)

"""The fit method trains the Random Forest model on the training data by building a forest of decision trees and optimizing the splits of the trees to minimize the mean squared error between the predicted quality scores and the actual quality scores. """

#Let's see how our model performed
print(classification_report(y_test, pred_rfc))


#Confusion matrix for the random forest classification
print(confusion_matrix(y_test, pred_rfc))

"""

![image.png](data:image/png;base64,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)

## Support Vector Classifier

During the training phase, the SVM algorithm finds the hyperplane that best separates the training data into their respective classes. The hyperplane is determined by finding the maximum margin between the training data points and the decision boundary. The margin is the distance between the hyperplane and the nearest data points from each class.

Once the hyperplane has been identified, the SVM algorithm can use it to predict the class of new, unseen data points. The algorithm computes the distance between the new data point and the hyperplane, and based on the side of the hyperplane that the data point falls on, it is classified as belonging to one of the classes.

Support Vector Classifier (SVC) is a variant of SVM used for classification tasks. It works by finding the optimal hyperplane that separates the data points belonging to different classes, while maximizing the margin.
"""

svc = SVC()
svc.fit(X_train, y_train)
pred_svc = svc.predict(X_test)

print(classification_report(y_test, pred_svc))

"""#### Support vector classifier gets 86%

## Let's try to increase our accuracy of models
## Grid Search CV

Grid Search CV is a technique used in machine learning to tune hyperparameters of a model by searching over a range of values for each hyperparameter and finding the combination that yields the best performance.

Grid Search CV is often used in conjunction with Support Vector Machines (SVMs) to find the best hyperparameters for the SVM model.
"""

#Finding best parameters for our SVC model
param = {
    'C': [0.1,0.8,0.9,1,1.1,1.2,1.3,1.4],
    'kernel':['linear', 'rbf'],
    'gamma' :[0.1,0.8,0.9,1,1.1,1.2,1.3,1.4]
}
grid_svc = GridSearchCV(svc, param_grid=param, scoring='accuracy', cv=10)

"""C, kernel, and gamma are hyperparameters of the Support Vector Machine (SVM) model that we are trying to optimize using GridSearchCV."""

grid_svc.fit(X_train, y_train)

#Best parameters for our svc model
grid_svc.best_params_

#Let's run our SVC again with the best parameters.
svc2 = SVC(C = 1.2, gamma =  0.9, kernel= 'rbf')
svc2.fit(X_train, y_train)
pred_svc2 = svc2.predict(X_test)
print(classification_report(y_test, pred_svc2))




#Now lets try to do some evaluation for random forest model using cross validation.
rfc_eval = cross_val_score(estimator = rfc, X = X_train, y = y_train, cv = 10)
rfc_eval.mean()

"""### Random forest accuracy increases from 87% to 91 % using cross validation score"""